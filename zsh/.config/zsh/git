#!/usr/bin/env zsh

# TODO: make it permanent that worktrees add origin tracking#
# EXAMPLE git config file:
# https://stackoverflow.com/questions/54367011/git-bare-repositories-worktrees-and-tracking-branches
#
# change default branch in a bare repo:
# https://stackoverflow.com/questions/3301956/git-correct-way-to-change-active-branch-in-a-bare-repository
# ---------------------------------------------
# [core]
# 	repositoryformatversion = 0
# 	filemode = true
# 	bare = true
# 	ignorecase = true
# 	precomposeunicode = true
# 	logallrefupdates = true
# [remote "origin"]
# 	url = git@github.com:sunnustech/app.git
#   fetch = +refs/heads/*:refs/remotes/origin/* 
# [branch "feature/scoreboard"]
# 	remote = origin
# 	merge = refs/heads/feature/scoreboard
#  THIS IS THE IMPORTANT LINE
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
# ---------------------------------------------

gn() { $EDITOR $(git rev-parse --git-dir)/gitnu.json }
alias gs="git number" # git status
alias ga="git number add"
alias gaa="git add --all"
alias gcf="git config --edit"
alias gd="git number diff"
alias gds="git number diff --staged"
alias giti="$EDITOR .gitignore"
alias gr="git number reset"
alias grh="git number reset --hard"
alias gitm="$EDITOR .gitmodules"
alias gcan="git commit --amend --no-edit"
alias gf="git fetch"
alias gap="git number add -p"
alias gms="git merge --squash" # squash diff into one commit
alias gm="git merge" # squash diff into one commit
alias gmn="git merge --no-ff" # squash diff into one commit
alias gu="git fetch && git status" # git update
alias gc="git commit"
alias gce="git commit --allow-empty -m"
alias gcn="git clean -fxd --exclude=\"node_modules\""
alias gcnn="git clean -fxd"
alias gp="git number -c nvim"
alias grpo="git remote prune origin"

function mongl() {
  # monitor git log
  while; do; clear; gla ${1-25}; sleep 2; done
}

function gco() {
  local OUTPUT MATCH RE WORKTREES

  # this will already execute the original command
  OUTPUT="$(git number checkout $@ 2>&1)"

  # just go to the place that's already checked out
  RE='^fatal: .* is already checked out at (.*)$'
  [[ $OUTPUT =~ $RE ]] && cd ${match[1]:1:-1} && return

  # if it's any other message then this, then gco is no good
  MATCH="fatal: this operation must be run in a work tree"
  [[ $OUTPUT != $MATCH ]] && echo $OUTPUT && return

  # iterate through worktrees and find target
  WORKTREES=("${(@f)$(git worktree list --porcelain)}")
  for line in ${WORKTREES[@]}; do
    # if line begins with 'worktree', use it to set dir
    [[ $line =~ '^worktree (.*)$' ]] && dir=${match[1]} && continue
    # if line begins with 'branch' and matches target, go to it
    [[ $line =~ '^branch refs/heads/(.*)$' ]] \
      && [[ ${match[1]} == $1 ]] \
      && cd $dir && return
  done
}

# git clone
function gcl() {
  [ ${1%%:*} = "https" ] \
    && git clone $1 && return
  [ ${1%%:*} = "git@github.com" ] \
    && git clone $1 && return
}

# git clone --bare
function gcb() {
  [ ${1%%:*} = "https" ] \
    && git clone --bare $1 && return
  [ ${1%%:*} = "git@github.com" ] \
    && git clone --bare $1 && return
}

function glt() { git log --since="24 hours ago" --oneline --graph --all } # git log (today)

# git logs
log_pretty() {
  local f="%C(yellow)%h%C(auto)%d %Creset%s %C(dim)(%ar)"
  git log $@ --pretty=format:$f
}

log_message() {
  local f="%C(yellow)%h %Creset%s"
  git log $@ --all --pretty=format:$f
}

function gl()  { log_pretty --graph -n ${1-20} }
function gla() { log_pretty --graph -n ${1-20} --all }
function gll() { log_pretty --graph --all }
function glf() { log_pretty --graph --follow }

# git search log
function gsl() {
  log_message --color=always \
    | fzf $FZF_OPTS --ansi --multi 6 --bind 'enter:select-all+accept'
}

# git search log (with filenames)
gslf() {
  log_message --compact-summary | $EDITOR -
}

# git commit
gcm() {
  local cmd=(git commit)
  [ $1 ] && $cmd -m $1 || $cmd
}

# git commit --amend
gca() {
  local cmd=(git commit --amend)
  [ $1 ] && $cmd -m $1 || $cmd
}

function gb() {
  [ $1 ] && git branch "$@" \
    || (branch=$(git branch | fzf $FZF_OPTS) \
    && [ $branch ] && gco ${branch[3,-1]})
}

function yeet() {
  f() { # (those are not spaces)
    git push >/dev/null 2>&1 \
      && notify 'âœ… git push successful' 'â €' \
      || notify 'ðŸ”¥ git push failed' 'â €'
  }; (f &)
  echo "async pushed."
}

# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3b.  mv a/submodule_tmp a/submodule
# remove a file with sensitive data from history
# git filter-repo --invert-paths --path secrets.json

# to change an old commit message:
# git rebase -i HEAD~5
# this displays the latest 5 commits in vim
# change "pick" to "reword" or "r" (read instructions opened in vim)
# write and quit
# those commits whose lines changed to "r" will be editable

# remove a secrets file from all git history:
# [https://stackoverflow.com/questions/43762338/how-to-remove-file-from-git-history]
# git filter-branch --index-filter "git rm -rf --cached --ignore-unmatch path_to_file" HEAD

#!/usr/bin/env zsh

# TODO: make it permanent that worktrees add origin tracking#
# EXAMPLE git config file:
# https://stackoverflow.com/questions/54367011/git-bare-repositories-worktrees-and-tracking-branches
#
# change default branch in a bare repo:
# https://stackoverflow.com/questions/3301956/git-correct-way-to-change-active-branch-in-a-bare-repository
# ---------------------------------------------
# [core]
# 	repositoryformatversion = 0
# 	filemode = true
# 	bare = true
# 	ignorecase = true
# 	precomposeunicode = true
# 	logallrefupdates = true
# [remote "origin"]
# 	url = git@github.com:sunnustech/app.git
#   fetch = +refs/heads/*:refs/remotes/origin/* 
# [branch "feature/scoreboard"]
# 	remote = origin
# 	merge = refs/heads/feature/scoreboard
#  THIS IS THE IMPORTANT LINE
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
#   fetch = +refs/heads/*:refs/remotes/origin/* 
# ---------------------------------------------

# highly used
alias gs="git number" # git status
alias ga="git number add"
alias gaa="git add --all"
alias gc="git commit"
alias gcan="git commit --amend --no-edit"
alias gcn="git clean -fxd --exclude=\"node_modules\""
alias gcnn="git clean -fxd"
alias gd="git number diff"
alias gds="git number diff --staged"
alias gf="git fetch"
alias giti="$EDITOR .gitignore"
alias gm="git merge" # squash diff into one commit
alias gmn="git merge --no-ff" # squash diff into one commit
alias gms="git merge --squash" # squash diff into one commit
alias gp="git number -c nvim"
alias gpdo="git push -d origin"
alias gr="git number reset"
alias grh="git number reset --hard"
alias grpo="git remote prune origin"

# still essential
alias gcf="git config --edit"
alias gitm="$EDITOR .gitmodules"

# probably useless
alias gce="git commit --allow-empty -m"
alias gap="git number add -p"
alias gu="git fetch && git status" # git update

# git checkout, without speedbumps
# just get there already.
gco() {
  local OUTPUT MATCH RE WORKTREES BASENAME_DIR
  local GY='\033[0;37m'  # Gray
  local GN='\033[0;32m'  # Green
  local NC='\033[0m'     # No color

  # this will already execute the original command
  OUTPUT="$(git number checkout $@ 2>&1)"
  original() { printf "${GY}$OUTPUT${NC}\n" }
  jump() { printf "${GY}jumped to worktree ${GN}${1}${NC}\n" }

  # nothing to do if outside git/already there
  RE='^(fatal: not a git repository|Already on).*$'
  [[ $OUTPUT =~ $RE ]] && original && return

  # just go to the place that's already checked out
  RE='^fatal: .* is already checked out at (.*)$'
  [[ $OUTPUT =~ $RE ]] && jump $1 && cd ${match[1]:1:-1} && return

  # try to jump to a worktree
  WORKTREES=("${(@f)$(git worktree list --porcelain)}")
  # iterate through worktrees and find target
  for line in ${WORKTREES[@]}; do
    # if line begins with 'worktree', use it to set dir and base
    if [[ $line =~ '^worktree (.*)$' ]]; then
      dir=${match[1]}; base=${line##*/}
      [[ $base == $1 ]] && BASENAME_DIR=$dir
      continue
    fi
    # if line begins with 'branch' and matches target, go to it
    [[ $line =~ '^branch refs/heads/(.*)$' ]] \
      && [[ ${match[1]} == $1 ]] \
      && jump $1 && cd $dir && return
  done

  # if no branch matches, try to jump to a matching directory
  [ $BASENAME_DIR ] && jump "@$1" && cd $BASENAME_DIR && return

  # finally, just echo out the original message
  original
}

# custom git clone
cyclone() {
  local repo=${@[-1]} # the last argument
  local cmd=(${@:1:-1}) # everything but the last
  ([[ $repo =~ '^https://.*/.*/' ]] && $cmd $repo) || \
  ([[ $repo =~ '^git@.*:.*/' ]] && $cmd $repo) || \
  ([[ $repo =~ '^(.*)/(.*)$' ]] && $cmd git@github.com:${match[1]}/${match[2]}.git)
}

# git clone
gcl() { cyclone git clone $@ }

# git clone --bare
gcb() { cyclone git clone --bare $@ }

# git log + graph template
log_graph() {
  local f="%C(yellow)%h%C(auto)%d %Creset%s %C(dim)(%ar)"
  git log --graph --pretty=format:$f $@ 
}

# git log + message template
log_message() {
  local f="%C(yellow)%h %Creset%s"
  git log --all --pretty=format:$f $@
}

# git logs
let lines="$LINES - 15"
gl() { log_graph -n ${1-$lines} }
gla() { log_graph -n ${1-$lines} --all }
gll() { log_graph --all }
glf() { log_graph --follow $1 }
mongl() { while; do; clear; gla ${1-lines}; sleep 2; done }

# git search log
gsl() {
  log_message --color=always \
    | fzf $FZF_OPTS --ansi --multi 6 --bind 'enter:select-all+accept'
}

# git search log (with filenames) and open in editor
gslf() {
  log_message --compact-summary | $EDITOR -
}

# git commit
gcm() {
  local cmd=(git commit)
  [ $1 ] && $cmd -m $1 || $cmd
}

# git commit --amend
gca() {
  local cmd=(git commit --amend)
  [ $1 ] && $cmd -m $1 || $cmd
}

gb() {
  if [ -z $1 ]; then
    branch=$(git branch | fzf $FZF_OPTS)
    [ $branch ] && gco ${branch[3,-1]}
    return
  fi
  git branch "$@"
}

yeet() {
  f() { # (those are not spaces)
    git push >/dev/null 2>&1 \
      && notify 'âœ… git push successful' 'â €' \
      || notify 'ðŸ”¥ git push failed' 'â €'
  }; (f &)
  echo "async pushed."
}

# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3b.  mv a/submodule_tmp a/submodule
# remove a file with sensitive data from history
# git filter-repo --invert-paths --path secrets.json

# to change an old commit message:
# git rebase -i HEAD~5
# this displays the latest 5 commits in vim
# change "pick" to "reword" or "r" (read instructions opened in vim)
# write and quit
# those commits whose lines changed to "r" will be editable

# remove a secrets file from all git history:
# [https://stackoverflow.com/questions/43762338/how-to-remove-file-from-git-history]
# git filter-branch --index-filter "git rm -rf --cached --ignore-unmatch path_to_file" HEAD

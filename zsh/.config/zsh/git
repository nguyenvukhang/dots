#!/usr/bin/env zsh

# TODO: make it permanent that worktrees add origin tracking#
# EXAMPLE git config file:
# https://stackoverflow.com/questions/54367011/git-bare-repositories-worktrees-and-tracking-branches
#
# change default branch in a bare repo:
# https://stackoverflow.com/questions/3301956/git-correct-way-to-change-active-branch-in-a-bare-repository
# ---------------------------------------------
# [core]
# 	repositoryformatversion = 0
# 	filemode = true
# 	bare = true
# 	ignorecase = true
# 	precomposeunicode = true
# 	logallrefupdates = true
# [remote "origin"]
# 	url = git@github.com:sunnustech/app.git
#   fetch = +refs/heads/*:refs/remotes/origin/*
# [branch "feature/scoreboard"]
# 	remote = origin
# 	merge = refs/heads/feature/scoreboard
# ---------------------------------------------

GIT=(git number)

gn() {
  $EDITOR $(git rev-parse --git-dir)/gitnu.json
}
gs()   { $GIT $@ } # git status
ga()   { $GIT add $@ }
gaa()  { git add --all $@ }
gcf()  { git config --edit $@ }
gd()   { $GIT diff $@ }
gds()  { $GIT diff --staged $@ }
giti() { $EDITOR .gitignore $@ }
gr()   { $GIT reset $@ }
grh()  { $GIT reset --hard $@ }
gitm() { $EDITOR .gitmodules $@ }
gcan() { git commit --amend --no-edit $@ }
gf()   { git fetch $@ }
gap()  { $GIT add -p $@ }
gms()  { git merge --squash $@ } # squash diff into one commit
gm()   { git merge $@ } # squash diff into one commit
gmn()   { git merge --no-ff $@ } # squash diff into one commit
gu()   { git fetch && git status $@ } # git update
gc()   { git commit $@ }
gce()  { git commit --allow-empty -m $@ }

function gco() {
  local OUTPUT TARGET MATCH CWD TARGET_ROOT TARGET_DIR

  # this will already execute the original command
  OUTPUT=$($GIT checkout $@ 2>&1)

  # this function seeks to handle error messages
  TARGET="$1"

  MATCH="fatal: '$TARGET' is already checked out at '"

  # inside a worktree
  if [[ "$OUTPUT" == "$MATCH"* ]]; then
    TARGET_ROOT=${${OUTPUT#*$MATCH}[0,-2]}
    CWD=$(git rev-parse --show-prefix)
    TARGET_DIR=$TARGET_ROOT/$CWD
    [ -d $TARGET_DIR ] \
      && cd $TARGET_DIR \
      || cd $TARGET_ROOT
    return 0
  fi

  MATCH="fatal: this operation must be run in a work tree"

  # just outside a worktree
  if [[ "$OUTPUT" == "$MATCH" ]]; then
    # keys: branch name
    # values: branch root dir
    typeset -A local WORKTREES=()
    local dir
    while IFS= read -r line; do
      if [[ "$line" == "worktree"* ]]; then
        dir="${line#*worktree }"
      elif [[ "$line" == "branch"* ]]; then
        local branch="${line##*/}"
        WORKTREES[$branch]="$dir"
      fi
    done < <(git worktree list --porcelain)
    cd $WORKTREES[$branch]
    return 0
  fi

  # when all fails, just echo original output
  echo $OUTPUT
}

# git clone
function gcl() {
  [ ${1%%:*} = "https" ] \
    && git clone $1 && return
  [ ${1%%:*} = "git@github.com" ] \
    && git clone $1 && return
  git clone git@github.com:$1.git
}

# git clone --bare
function gcb() {
  [ ${1%%:*} = "https" ] \
    && git clone --bare $1 && return
  [ ${1%%:*} = "git@github.com" ] \
    && git clone --bare $1 && return
  git clone --bare git@github.com:$1.git
}

function glt() { git log --since="24 hours ago" --oneline --graph --all } # git log (today)

# git logs
function custom_git_log() {
  local pretty="%C(yellow)%h%C(auto)%d %Creset%s %C(dim)(%ar)"
  git log $@ --graph --pretty=format:$pretty
}
function gl()  { custom_git_log -n ${1-12} }
function gla() { custom_git_log -n ${1-12} --all }
function glf() { custom_git_log --follow }

# git search log
function gsl() {
  custom_git_log --all \
    | fzf $FZF_OPTS --multi 6 --bind 'enter:select-all+accept'
}

# git commit
function gcm() {
  [ $1 ] && git commit -m $1 && return true
  git commit
}

# git commit --amend
function gca() {
  [ $1 ] && git commit --amend -m $1 && return true
  git commit --amend
}

# the laziest git function ever
function gq() {
  git add .
  [ "$1" = "-w" ] \
    && git commit --amend --no-edit \
    || git commit -m 'up'
  git push
}

function gb() {
  if [ $1 ]; then; git branch "$@"; return; fi
  # fzf-branch (switch branch)
  branch=$(git branch | fzf $FZF_OPTS)
  [ $branch ] && gco ${branch[3,-1]} || return 0
}

function gur() {
  git commit -m "update ref"
  git push
}

# delete branch
# git branch -d <branch_name>

# delete remote branch
# git push origin -d <branch_name>

# to remove a submodule completely:
# 0. mv a/submodule a/submodule_tmp
# 1. git submodule deinit -f -- a/submodule    
# 2. rm -rf .git/modules/a/submodule
# 3. git rm -f a/submodule
# Note: a/submodule (no trailing slash)
# 
# or, if you want to leave it in your working tree and have done step 0
# 3.   git rm --cached a/submodule
# 3b.  mv a/submodule_tmp a/submodule
# remove a file with sensitive data from history
# git filter-repo --invert-paths --path secrets.json

# to change an old commit message:
# git rebase -i HEAD~5
# this displays the latest 5 commits in vim
# change "pick" to "reword" or "r" (read instructions opened in vim)
# write and quit
# those commits whose lines changed to "r" will be editable

# remove a secrets file from all git history:
# [https://stackoverflow.com/questions/43762338/how-to-remove-file-from-git-history]
# git filter-branch --index-filter "git rm -rf --cached --ignore-unmatch path_to_file" HEAD

# ============
# git worktree
# ============
#
# git worktree add [-f] [--detach] [--checkout] [--lock] [-b <new-branch>] <path> [<commit-ish>]
#
# to add a new branch:
# git worktree add -b <branch> ../<directory>

function gwnb() {
  git worktree add -b $1 ../$1
}

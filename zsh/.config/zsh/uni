#!/usr/bin/env zsh

# uni: create worktree
function uw() {
  local worktree=$REPOS/uni

  local get_query_and_module=$(fd -t d -d 1 '^[A-Z]{2,3}[0-9]{4}[A-Z]?$' \
    --base-directory $worktree/master/modules \
    --exec basename | fzf $FZF_OPTS --print-query)

  local qm=(); while IFS= read -r line; do qm+=( "$line" )
  done < <( echo $get_query_and_module )

  local query=${qm[1]}; local module=${qm[2]}

  [[ -z $query && -z $module ]] && echo "Nothing queried. Quitting." && return 0
  [ -z $module ] && module="$query"

  local function jump_there() {
    cd $worktree/$module/modules/$module 2>/dev/null \
        || cd $worktree/$module/modules
  }

  # check if there's current an existing git branch
  # with the same name (may not be a worktree)
  local branches=$(git -C $worktree branch --format='%(refname:short)')

  local has_branch=false
  (($branches[(Ie)$module])) && has_branch=true

  # check if worktree exists
  local has_worktree=false
  [ -d $worktree/$module ] && has_worktree=true

  if [ "$has_worktree" = true ]; then
    jump_there
  else # no worktree
    if [ "$has_branch" = true ]; then
      echo "A branch called \"$module\" already exists."
      return 1
    else # no branch
      # create worktree and branch at the same time
      git -C $worktree worktree add $module
      jump_there
    fi
  fi
}

# uni: delete worktree
function ud() {
  _N='\033[0m'    # Normal
  _Y='\033[0;33m' # Yellow
  _B='\033[0;34m' # Blue

  local UNI=$REPOS/uni

  # get list of worktrees (except for master)
  declare -A local worktrees
  while IFS= read -r line; do
    [[ ${line%% *} != "worktree" ]] && continue
    # worktree path is everything after "worktree " in that line
    worktree_path=${line##*worktree }
    # worktree name is the text following the UNI variable
    # and after the slash
    worktree_name=${${line##*$UNI}##*/}

    # reject the worktree root and the master worktree
    [[ $worktree_name == "master" || -z $worktree_name ]] && continue

    # add to list of worktrees
    worktrees[$worktree_name]="$worktree_path"
  done < <(git -C $UNI worktree list --porcelain)

  # if there are no valid worktrees to delete, quit out
  [[ -z $worktrees ]] && echo "No worktrees to delete. Quitting." && return 0

  # prompt user for which worktree to delete
  local to_delete=$(for key in ${(k)worktrees}; do; echo $key; done \
    | fzf $FZF_OPTS)

  # if nothing is selected, quit out
  [[ -z $to_delete ]] && echo "Nothing selected. Quitting." && return 0

  # get the branch that's currently checked out on that worktree
  local worktree_path=$worktrees[$to_delete]
  local branch=$(git -C $worktree_path branch --show-current)

  git -C $worktree_path log --graph -n 5 \
    --pretty=format:"%C(yellow)%h%C(auto)%d %Creset%s %C(dim)(%ar)"

  # ask for confirmation, since this proceeding will forcefully
  # delete both worktree and the associated branch
  [[ $branch == $to_delete ]] \
    && printf "\n${_B}confirm deletion of worktree ${_Y}$to_delete${_B}?${_N}" \
    || printf "\n${_B}confirm deletion of worktree ${_Y}$to_delete${_B} @ branch ${_Y}$branch${_B}?${_N}"
  local confirm=$(printf "yes\nno" | fzf $FZF_OPTS)

  # quit if "no" or escaped
  [[ $confirm == "no" || -z $confirm ]] && echo "Deletion cancelled." && return 0

  # proceed with deletion fo worktree and checked out branch
  local ok_worktree=false; local ok_branch=false
  git -C $UNI worktree remove $to_delete && ok_worktree=true
  git -C $UNI branch -D $branch && ok_branch=true
  echo "Deleted worktree $to_delete."
  cd $REPOS/uni
}

# uni: merge master
function umm() {
  local worktree=$REPOS/uni
  local branches=()
  while IFS= read -r line; do
    [ "$line" != "master" ] && branches+=("$line")
  done < <(git -C $worktree branch --format='%(refname:short)')
  local to_merge=$(for i in $branches; do; echo $i; done | fzf $FZF_OPTS)
  [ -z $to_merge ] && return 0
  local confirm=$(printf "yes\nno" | fzf $FZF_OPTS \
    --prompt "confirm pull master to $to_merge?")
  [[ $confirm == "no" ]] && echo "pull cancelled." && return 0
  git -C $worktree/master checkout master >/dev/null
  git -C $worktree/master merge $to_merge
}
